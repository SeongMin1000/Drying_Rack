
Dry_Conditioner.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  0000040c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000398  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000007  00800100  00800100  0000040c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000040c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000043c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001e0  00000000  00000000  0000047c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001530  00000000  00000000  0000065c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d64  00000000  00000000  00001b8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000d71  00000000  00000000  000028f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000368  00000000  00000000  00003664  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000695  00000000  00000000  000039cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000787  00000000  00000000  00004061  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000150  00000000  00000000  000047e8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__vector_1>
   8:	0c 94 8c 00 	jmp	0x118	; 0x118 <__vector_2>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__vector_5>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 86 01 	jmp	0x30c	; 0x30c <__vector_7>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e8 e9       	ldi	r30, 0x98	; 152
  7c:	f3 e0       	ldi	r31, 0x03	; 3
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a0 30       	cpi	r26, 0x00	; 0
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	21 e0       	ldi	r18, 0x01	; 1
  8c:	a0 e0       	ldi	r26, 0x00	; 0
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a7 30       	cpi	r26, 0x07	; 7
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 5e 01 	call	0x2bc	; 0x2bc <main>
  9e:	0c 94 ca 01 	jmp	0x394	; 0x394 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <ADC_init>:
//추후에 더 많은 ADC를 사용할 수 있으므로 유지보수가 쉽도록 이렇게 코드 작성했습니다
uint16_t channels[MOISTURE_CHANNELS] = {0, 3}; //젖은 빨래 ADC 값을 읽을 센서 채널

// ADC 초기화 함수
void ADC_init() {
	ADMUX = (1 << REFS0); // AVCC를 기준 전압으로 사용
  a6:	80 e4       	ldi	r24, 0x40	; 64
  a8:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7f807c>
	ADCSRA = (1 << ADEN) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0); // 분주비 128 설정
  ac:	87 e8       	ldi	r24, 0x87	; 135
  ae:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7f807a>
  b2:	08 95       	ret

000000b4 <__vector_1>:
volatile uint8_t reserve_hours = 0;  // 예약 시간 (0=없음, 1~8시간)
volatile uint8_t start_flag = 0;


// ================= 예약 버튼 ISR (PD2 / INT0) =================
ISR(INT0_vect) {
  b4:	1f 92       	push	r1
  b6:	0f 92       	push	r0
  b8:	0f b6       	in	r0, 0x3f	; 63
  ba:	0f 92       	push	r0
  bc:	11 24       	eor	r1, r1
  be:	8f 93       	push	r24
	reserve_hours++;
  c0:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <reserve_hours>
  c4:	8f 5f       	subi	r24, 0xFF	; 255
  c6:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <reserve_hours>
	if (reserve_hours > 8) reserve_hours = 1;
  ca:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <reserve_hours>
  ce:	89 30       	cpi	r24, 0x09	; 9
  d0:	18 f0       	brcs	.+6      	; 0xd8 <__vector_1+0x24>
  d2:	81 e0       	ldi	r24, 0x01	; 1
  d4:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <reserve_hours>
}
  d8:	8f 91       	pop	r24
  da:	0f 90       	pop	r0
  dc:	0f be       	out	0x3f, r0	; 63
  de:	0f 90       	pop	r0
  e0:	1f 90       	pop	r1
  e2:	18 95       	reti

000000e4 <__vector_5>:

// ================= 바람세기 버튼 ISR (PD7 / INT7) =================
ISR(PCINT2_vect) {
  e4:	1f 92       	push	r1
  e6:	0f 92       	push	r0
  e8:	0f b6       	in	r0, 0x3f	; 63
  ea:	0f 92       	push	r0
  ec:	11 24       	eor	r1, r1
  ee:	8f 93       	push	r24
	if (!(PIND & (1 << PD7))) {
  f0:	4f 99       	sbic	0x09, 7	; 9
  f2:	0c c0       	rjmp	.+24     	; 0x10c <__vector_5+0x28>
		fan_mode++;
  f4:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <fan_mode>
  f8:	8f 5f       	subi	r24, 0xFF	; 255
  fa:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <fan_mode>
		if (fan_mode > 4) fan_mode = 1;
  fe:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <fan_mode>
 102:	85 30       	cpi	r24, 0x05	; 5
 104:	18 f0       	brcs	.+6      	; 0x10c <__vector_5+0x28>
 106:	81 e0       	ldi	r24, 0x01	; 1
 108:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <fan_mode>
	}
}
 10c:	8f 91       	pop	r24
 10e:	0f 90       	pop	r0
 110:	0f be       	out	0x3f, r0	; 63
 112:	0f 90       	pop	r0
 114:	1f 90       	pop	r1
 116:	18 95       	reti

00000118 <__vector_2>:

// ================= 시작 버튼 ISR (PD3 / INT1) =================
ISR(INT1_vect) {
 118:	1f 92       	push	r1
 11a:	0f 92       	push	r0
 11c:	0f b6       	in	r0, 0x3f	; 63
 11e:	0f 92       	push	r0
 120:	11 24       	eor	r1, r1
 122:	8f 93       	push	r24
	start_flag = 1;
 124:	81 e0       	ldi	r24, 0x01	; 1
 126:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
}
 12a:	8f 91       	pop	r24
 12c:	0f 90       	pop	r0
 12e:	0f be       	out	0x3f, r0	; 63
 130:	0f 90       	pop	r0
 132:	1f 90       	pop	r1
 134:	18 95       	reti

00000136 <button_init>:


// ================= 버튼 및 인터럽트 초기화 =================
void button_init(void) {
	// PD2(INT0), PD3(INT1), PD7(INT7) 입력 + 풀업
	DDRD &= ~((1 << PD2) | (1 << PD3) | (1 << PD7));
 136:	8a b1       	in	r24, 0x0a	; 10
 138:	83 77       	andi	r24, 0x73	; 115
 13a:	8a b9       	out	0x0a, r24	; 10
	PORTD |= (1 << PD2) | (1 << PD3) | (1 << PD7);
 13c:	8b b1       	in	r24, 0x0b	; 11
 13e:	8c 68       	ori	r24, 0x8C	; 140
 140:	8b b9       	out	0x0b, r24	; 11

	// 외부 인터럽트 활성화
	EIMSK |= (1 << INT0) | (1 << INT1);
 142:	8d b3       	in	r24, 0x1d	; 29
 144:	83 60       	ori	r24, 0x03	; 3
 146:	8d bb       	out	0x1d, r24	; 29

	// INT0, INT1: 하강 에지 트리거
	EICRA |= (1 << ISC01) | (1 << ISC11);
 148:	e9 e6       	ldi	r30, 0x69	; 105
 14a:	f0 e0       	ldi	r31, 0x00	; 0
 14c:	80 81       	ld	r24, Z
 14e:	8a 60       	ori	r24, 0x0A	; 10
 150:	80 83       	st	Z, r24
	
	PCICR |= (1 << PCIE2); //PORTD 전체 핀체인지 인터럽트 허용
 152:	e8 e6       	ldi	r30, 0x68	; 104
 154:	f0 e0       	ldi	r31, 0x00	; 0
 156:	80 81       	ld	r24, Z
 158:	84 60       	ori	r24, 0x04	; 4
 15a:	80 83       	st	Z, r24
	PCMSK2 |= (1 << PCINT23); //PD7만 허용
 15c:	ed e6       	ldi	r30, 0x6D	; 109
 15e:	f0 e0       	ldi	r31, 0x00	; 0
 160:	80 81       	ld	r24, Z
 162:	80 68       	ori	r24, 0x80	; 128
 164:	80 83       	st	Z, r24
 166:	08 95       	ret

00000168 <gpio_init>:


void gpio_init(void)
{
	// LED 핀들을 출력으로 설정
	LED_DDR |= (1 << LED0_PIN) | (1 << LED1_PIN);
 168:	87 b1       	in	r24, 0x07	; 7
 16a:	86 60       	ori	r24, 0x06	; 6
 16c:	87 b9       	out	0x07, r24	; 7
	// 부저 핀을 출력으로 설정
	BUZZER_DDR |= (1 << BUZZER_PIN);
 16e:	84 b1       	in	r24, 0x04	; 4
 170:	81 60       	ori	r24, 0x01	; 1
 172:	84 b9       	out	0x04, r24	; 4
	
	// 모든 LED와 부저를 끈 상태로 시작
	LED_PORT &= ~((1 << LED0_PIN) | (1 << LED1_PIN));
 174:	88 b1       	in	r24, 0x08	; 8
 176:	89 7f       	andi	r24, 0xF9	; 249
 178:	88 b9       	out	0x08, r24	; 8
	BUZZER_PORT &= ~(1 << BUZZER_PIN);
 17a:	85 b1       	in	r24, 0x05	; 5
 17c:	8e 7f       	andi	r24, 0xFE	; 254
 17e:	85 b9       	out	0x05, r24	; 5
 180:	08 95       	ret

00000182 <i2c_init>:
#include "i2c.h"

// 100kHz SCL 주파수 설정 (F_CPU = 16MHz)
void i2c_init(void)
{
	TWSR = 0x00; // 프리스케일러 1
 182:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7f80b9>
	TWBR = 72;   // Bit Rate 설정
 186:	88 e4       	ldi	r24, 0x48	; 72
 188:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7f80b8>
	TWCR = (1 << TWEN);
 18c:	84 e0       	ldi	r24, 0x04	; 4
 18e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 192:	08 95       	ret

00000194 <i2c_start>:
}

void i2c_start(void)
{
	TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
 194:	84 ea       	ldi	r24, 0xA4	; 164
 196:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
	while (!(TWCR & (1 << TWINT)));
 19a:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 19e:	88 23       	and	r24, r24
 1a0:	e4 f7       	brge	.-8      	; 0x19a <i2c_start+0x6>
}
 1a2:	08 95       	ret

000001a4 <i2c_stop>:

void i2c_stop(void)
{
	TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
 1a4:	84 e9       	ldi	r24, 0x94	; 148
 1a6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 1aa:	08 95       	ret

000001ac <i2c_write>:
}

void i2c_write(uint8_t data)
{
	TWDR = data;
 1ac:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7f80bb>
	TWCR = (1 << TWINT) | (1 << TWEN);
 1b0:	84 e8       	ldi	r24, 0x84	; 132
 1b2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
	while (!(TWCR & (1 << TWINT)));
 1b6:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7f80bc>
 1ba:	88 23       	and	r24, r24
 1bc:	e4 f7       	brge	.-8      	; 0x1b6 <i2c_write+0xa>
 1be:	08 95       	ret

000001c0 <lcd_pulse_enable>:
#define LCD_BL (1 << 3) // 백라이트

static uint8_t backlight_state = LCD_BL; // 백라이트 상태 저장

void lcd_pulse_enable(uint8_t data)
{
 1c0:	cf 93       	push	r28
 1c2:	c8 2f       	mov	r28, r24
	i2c_write(data | LCD_E);
 1c4:	84 60       	ori	r24, 0x04	; 4
 1c6:	0e 94 d6 00 	call	0x1ac	; 0x1ac <i2c_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1ca:	85 e0       	ldi	r24, 0x05	; 5
 1cc:	8a 95       	dec	r24
 1ce:	f1 f7       	brne	.-4      	; 0x1cc <lcd_pulse_enable+0xc>
 1d0:	00 00       	nop
	_delay_us(1);
	i2c_write(data & ~LCD_E);
 1d2:	8c 2f       	mov	r24, r28
 1d4:	8b 7f       	andi	r24, 0xFB	; 251
 1d6:	0e 94 d6 00 	call	0x1ac	; 0x1ac <i2c_write>
 1da:	87 ec       	ldi	r24, 0xC7	; 199
 1dc:	90 e0       	ldi	r25, 0x00	; 0
 1de:	01 97       	sbiw	r24, 0x01	; 1
 1e0:	f1 f7       	brne	.-4      	; 0x1de <lcd_pulse_enable+0x1e>
 1e2:	00 c0       	rjmp	.+0      	; 0x1e4 <lcd_pulse_enable+0x24>
 1e4:	00 00       	nop
	_delay_us(50);
}
 1e6:	cf 91       	pop	r28
 1e8:	08 95       	ret

000001ea <lcd_send_nibble>:

void lcd_send_nibble(uint8_t nibble, uint8_t is_data)
{
 1ea:	cf 93       	push	r28
	uint8_t data = (nibble << 4) | backlight_state;
 1ec:	20 e1       	ldi	r18, 0x10	; 16
 1ee:	82 9f       	mul	r24, r18
 1f0:	c0 01       	movw	r24, r0
 1f2:	11 24       	eor	r1, r1
 1f4:	c8 2f       	mov	r28, r24
 1f6:	c8 60       	ori	r28, 0x08	; 8
	if (is_data) data |= LCD_RS;
 1f8:	61 11       	cpse	r22, r1
 1fa:	c1 60       	ori	r28, 0x01	; 1
	
	i2c_start();
 1fc:	0e 94 ca 00 	call	0x194	; 0x194 <i2c_start>
	i2c_write(LCD_I2C_ADDRESS);
 200:	8e e4       	ldi	r24, 0x4E	; 78
 202:	0e 94 d6 00 	call	0x1ac	; 0x1ac <i2c_write>
	i2c_write(data);
 206:	8c 2f       	mov	r24, r28
 208:	0e 94 d6 00 	call	0x1ac	; 0x1ac <i2c_write>
	lcd_pulse_enable(data);
 20c:	8c 2f       	mov	r24, r28
 20e:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <lcd_pulse_enable>
	i2c_stop();
 212:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <i2c_stop>
}
 216:	cf 91       	pop	r28
 218:	08 95       	ret

0000021a <lcd_send_byte>:

void lcd_send_byte(uint8_t byte, uint8_t is_data)
{
 21a:	cf 93       	push	r28
 21c:	df 93       	push	r29
 21e:	c8 2f       	mov	r28, r24
 220:	d6 2f       	mov	r29, r22
	lcd_send_nibble(byte >> 4, is_data);   // 상위 4비트
 222:	82 95       	swap	r24
 224:	8f 70       	andi	r24, 0x0F	; 15
 226:	0e 94 f5 00 	call	0x1ea	; 0x1ea <lcd_send_nibble>
	lcd_send_nibble(byte & 0x0F, is_data); // 하위 4비트
 22a:	6d 2f       	mov	r22, r29
 22c:	8c 2f       	mov	r24, r28
 22e:	8f 70       	andi	r24, 0x0F	; 15
 230:	0e 94 f5 00 	call	0x1ea	; 0x1ea <lcd_send_nibble>
}
 234:	df 91       	pop	r29
 236:	cf 91       	pop	r28
 238:	08 95       	ret

0000023a <lcd_clear>:
	lcd_clear();
}

void lcd_clear(void)
{
	lcd_send_byte(0x01, 0);
 23a:	60 e0       	ldi	r22, 0x00	; 0
 23c:	81 e0       	ldi	r24, 0x01	; 1
 23e:	0e 94 0d 01 	call	0x21a	; 0x21a <lcd_send_byte>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 242:	8f e3       	ldi	r24, 0x3F	; 63
 244:	9f e1       	ldi	r25, 0x1F	; 31
 246:	01 97       	sbiw	r24, 0x01	; 1
 248:	f1 f7       	brne	.-4      	; 0x246 <lcd_clear+0xc>
 24a:	00 c0       	rjmp	.+0      	; 0x24c <lcd_clear+0x12>
 24c:	00 00       	nop
 24e:	08 95       	ret

00000250 <lcd_init>:
	lcd_send_nibble(byte & 0x0F, is_data); // 하위 4비트
}

void lcd_init(void)
{
	i2c_init();
 250:	0e 94 c1 00 	call	0x182	; 0x182 <i2c_init>
 254:	2f ef       	ldi	r18, 0xFF	; 255
 256:	80 e7       	ldi	r24, 0x70	; 112
 258:	92 e0       	ldi	r25, 0x02	; 2
 25a:	21 50       	subi	r18, 0x01	; 1
 25c:	80 40       	sbci	r24, 0x00	; 0
 25e:	90 40       	sbci	r25, 0x00	; 0
 260:	e1 f7       	brne	.-8      	; 0x25a <lcd_init+0xa>
 262:	00 c0       	rjmp	.+0      	; 0x264 <lcd_init+0x14>
 264:	00 00       	nop
	_delay_ms(50);
	
	lcd_send_nibble(0x03, 0);
 266:	60 e0       	ldi	r22, 0x00	; 0
 268:	83 e0       	ldi	r24, 0x03	; 3
 26a:	0e 94 f5 00 	call	0x1ea	; 0x1ea <lcd_send_nibble>
 26e:	8f e1       	ldi	r24, 0x1F	; 31
 270:	9e e4       	ldi	r25, 0x4E	; 78
 272:	01 97       	sbiw	r24, 0x01	; 1
 274:	f1 f7       	brne	.-4      	; 0x272 <lcd_init+0x22>
 276:	00 c0       	rjmp	.+0      	; 0x278 <lcd_init+0x28>
 278:	00 00       	nop
	_delay_ms(5);
	lcd_send_nibble(0x03, 0);
 27a:	60 e0       	ldi	r22, 0x00	; 0
 27c:	83 e0       	ldi	r24, 0x03	; 3
 27e:	0e 94 f5 00 	call	0x1ea	; 0x1ea <lcd_send_nibble>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 282:	8f e8       	ldi	r24, 0x8F	; 143
 284:	91 e0       	ldi	r25, 0x01	; 1
 286:	01 97       	sbiw	r24, 0x01	; 1
 288:	f1 f7       	brne	.-4      	; 0x286 <lcd_init+0x36>
 28a:	00 c0       	rjmp	.+0      	; 0x28c <lcd_init+0x3c>
 28c:	00 00       	nop
	_delay_us(100);
	lcd_send_nibble(0x03, 0);
 28e:	60 e0       	ldi	r22, 0x00	; 0
 290:	83 e0       	ldi	r24, 0x03	; 3
 292:	0e 94 f5 00 	call	0x1ea	; 0x1ea <lcd_send_nibble>
	
	lcd_send_nibble(0x02, 0); // 4비트 모드 설정
 296:	60 e0       	ldi	r22, 0x00	; 0
 298:	82 e0       	ldi	r24, 0x02	; 2
 29a:	0e 94 f5 00 	call	0x1ea	; 0x1ea <lcd_send_nibble>
	
	lcd_send_byte(0x28, 0); // 4비트, 2라인, 5x8 폰트
 29e:	60 e0       	ldi	r22, 0x00	; 0
 2a0:	88 e2       	ldi	r24, 0x28	; 40
 2a2:	0e 94 0d 01 	call	0x21a	; 0x21a <lcd_send_byte>
	lcd_send_byte(0x0C, 0); // 디스플레이 ON, 커서 OFF
 2a6:	60 e0       	ldi	r22, 0x00	; 0
 2a8:	8c e0       	ldi	r24, 0x0C	; 12
 2aa:	0e 94 0d 01 	call	0x21a	; 0x21a <lcd_send_byte>
	lcd_send_byte(0x06, 0); // 엔트리 모드
 2ae:	60 e0       	ldi	r22, 0x00	; 0
 2b0:	86 e0       	ldi	r24, 0x06	; 6
 2b2:	0e 94 0d 01 	call	0x21a	; 0x21a <lcd_send_byte>
	lcd_clear();
 2b6:	0e 94 1d 01 	call	0x23a	; 0x23a <lcd_clear>
 2ba:	08 95       	ret

000002bc <main>:


int main(void)
{
    /* Replace with your application code */
    ADC_init();
 2bc:	0e 94 53 00 	call	0xa6	; 0xa6 <ADC_init>
    pwm_init();
 2c0:	0e 94 6e 01 	call	0x2dc	; 0x2dc <pwm_init>
    USART_init();
 2c4:	0e 94 be 01 	call	0x37c	; 0x37c <USART_init>
	timer_init();
 2c8:	0e 94 ab 01 	call	0x356	; 0x356 <timer_init>
	lcd_init();
 2cc:	0e 94 28 01 	call	0x250	; 0x250 <lcd_init>
	gpio_init();
 2d0:	0e 94 b4 00 	call	0x168	; 0x168 <gpio_init>
	button_init();
 2d4:	0e 94 9b 00 	call	0x136	; 0x136 <button_init>
	
	sei(); // 모든 초기화가 끝난 후 전역 인터럽트 활성화
 2d8:	78 94       	sei
 2da:	ff cf       	rjmp	.-2      	; 0x2da <main+0x1e>

000002dc <pwm_init>:
#include "pwm.h"

void pwm_init()
{
	// 1. 출력 핀 설정
	DDRB |= (1 << DDB1); // PB1 (OC1A) 핀을 출력으로
 2dc:	84 b1       	in	r24, 0x04	; 4
 2de:	82 60       	ori	r24, 0x02	; 2
 2e0:	84 b9       	out	0x04, r24	; 4

	// 2. 타이머 제어 레지스터 설정 (TCCR1A, TCCR1B)
	// non-inverting Fast PWM 모드(14), 64 프리스케일러
	TCCR1A |= (1 << COM1A1) | (1 << WGM11);
 2e2:	e0 e8       	ldi	r30, 0x80	; 128
 2e4:	f0 e0       	ldi	r31, 0x00	; 0
 2e6:	80 81       	ld	r24, Z
 2e8:	82 68       	ori	r24, 0x82	; 130
 2ea:	80 83       	st	Z, r24
	TCCR1B |= (1 << WGM13) | (1 << WGM12) | (1 << CS11) | (1 << CS10);
 2ec:	e1 e8       	ldi	r30, 0x81	; 129
 2ee:	f0 e0       	ldi	r31, 0x00	; 0
 2f0:	80 81       	ld	r24, Z
 2f2:	8b 61       	ori	r24, 0x1B	; 27
 2f4:	80 83       	st	Z, r24

	// 3. PWM 주기(주파수) 설정
	// 16MHz / (64 * 5000) = 50Hz
	ICR1 = 4999;
 2f6:	87 e8       	ldi	r24, 0x87	; 135
 2f8:	93 e1       	ldi	r25, 0x13	; 19
 2fa:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
 2fe:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>

	// 4. PWM 듀티 사이클 설정 (초기값 0%)
	OCR1A = 0;
 302:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
 306:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
 30a:	08 95       	ret

0000030c <__vector_7>:
static volatile unsigned long g_millis = 0;

// Timer2 비교 매치 인터럽트 서비스 루틴 (ISR)
// 1ms마다 g_millis를 1씩 증가시킴
ISR(TIMER2_COMPA_vect)
{
 30c:	1f 92       	push	r1
 30e:	0f 92       	push	r0
 310:	0f b6       	in	r0, 0x3f	; 63
 312:	0f 92       	push	r0
 314:	11 24       	eor	r1, r1
 316:	8f 93       	push	r24
 318:	9f 93       	push	r25
 31a:	af 93       	push	r26
 31c:	bf 93       	push	r27
	g_millis++;
 31e:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <g_millis>
 322:	90 91 04 01 	lds	r25, 0x0104	; 0x800104 <g_millis+0x1>
 326:	a0 91 05 01 	lds	r26, 0x0105	; 0x800105 <g_millis+0x2>
 32a:	b0 91 06 01 	lds	r27, 0x0106	; 0x800106 <g_millis+0x3>
 32e:	01 96       	adiw	r24, 0x01	; 1
 330:	a1 1d       	adc	r26, r1
 332:	b1 1d       	adc	r27, r1
 334:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <g_millis>
 338:	90 93 04 01 	sts	0x0104, r25	; 0x800104 <g_millis+0x1>
 33c:	a0 93 05 01 	sts	0x0105, r26	; 0x800105 <g_millis+0x2>
 340:	b0 93 06 01 	sts	0x0106, r27	; 0x800106 <g_millis+0x3>
}
 344:	bf 91       	pop	r27
 346:	af 91       	pop	r26
 348:	9f 91       	pop	r25
 34a:	8f 91       	pop	r24
 34c:	0f 90       	pop	r0
 34e:	0f be       	out	0x3f, r0	; 63
 350:	0f 90       	pop	r0
 352:	1f 90       	pop	r1
 354:	18 95       	reti

00000356 <timer_init>:

// 1ms 타이머 인터럽트를 설정하는 함수
void timer_init()
{
	// Timer2 CTC 모드, 64 프리스케일러 설정
	TCCR2A |= (1 << WGM21);
 356:	e0 eb       	ldi	r30, 0xB0	; 176
 358:	f0 e0       	ldi	r31, 0x00	; 0
 35a:	80 81       	ld	r24, Z
 35c:	82 60       	ori	r24, 0x02	; 2
 35e:	80 83       	st	Z, r24
	TCCR2B |= (1 << CS22);
 360:	e1 eb       	ldi	r30, 0xB1	; 177
 362:	f0 e0       	ldi	r31, 0x00	; 0
 364:	80 81       	ld	r24, Z
 366:	84 60       	ori	r24, 0x04	; 4
 368:	80 83       	st	Z, r24
	
	// 비교 매치 값 설정 (16MHz / 64 / 1000Hz = 250) -> 249
	OCR2A = 249;
 36a:	89 ef       	ldi	r24, 0xF9	; 249
 36c:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f80b3>
	
	// Timer2 비교 매치 인터럽트 활성화
	TIMSK2 |= (1 << OCIE2A);
 370:	e0 e7       	ldi	r30, 0x70	; 112
 372:	f0 e0       	ldi	r31, 0x00	; 0
 374:	80 81       	ld	r24, Z
 376:	82 60       	ori	r24, 0x02	; 2
 378:	80 83       	st	Z, r24
 37a:	08 95       	ret

0000037c <USART_init>:
#define BAUD 115200        // 115200 Baud Rate
#define UBRR_VALUE ((F_CPU / (16UL * BAUD)) - 1) 

void USART_init() {
	/* Baud rate 설정 */
	UBRR0H = (unsigned char)(UBRR_VALUE >> 8);
 37c:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
	UBRR0L = (unsigned char)UBRR_VALUE;
 380:	87 e0       	ldi	r24, 0x07	; 7
 382:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>

	/* 전송 활성화 (TX), 수신 비활성화 (RX는 활성화하지 않음) */
	UCSR0B = (1 << TXEN0);
 386:	88 e0       	ldi	r24, 0x08	; 8
 388:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>

	/* 8-bit 데이터 형식, 1 스톱 비트 */
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
 38c:	86 e0       	ldi	r24, 0x06	; 6
 38e:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
 392:	08 95       	ret

00000394 <_exit>:
 394:	f8 94       	cli

00000396 <__stop_program>:
 396:	ff cf       	rjmp	.-2      	; 0x396 <__stop_program>
